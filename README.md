# Optika

<img src="https://raw.githubusercontent.com/phadej/optika/master/optika-300.png" align="right" height="100" />

> Optics: modular data access

[![Build Status](https://secure.travis-ci.org/phadej/optika.svg?branch=master)](http://travis-ci.org/phadej/optika)
[![NPM version](https://badge.fury.io/js/optika.svg)](http://badge.fury.io/js/optika)
[![Dependency Status](https://david-dm.org/phadej/optika.svg)](https://david-dm.org/phadej/optika)
[![devDependency Status](https://david-dm.org/phadej/optika/dev-status.svg)](https://david-dm.org/phadej/optika#info=devDependencies)

## Getting Started

Install the module with: `npm install optika`

## Synopsis

```javascript
var o = require("optika");

var value = {
  foo: [
    { bar: 2, baz: 3 },
    { bar: 4, baz: 5 },
  ]
};

// [2, 4]
o.key("foo").traversed().key("bar").arrayOf(value);

// { foo: [ { bar: 9, baz: 3 }, { bar: 11, baz: 5 } ] }
o.key("foo").traversed().key("bar").over(value, function (x) {
  return x + 7;
});
```

## Motivation

[Immutable.js](https://facebook.github.io/immutable-js/) is great!
But working with immutable containers & nested records is un-easy:

```javascript
return data.update("months", months =>
  months.map(month =>
    month.update("days", days =>
      days.map(day => injectAuxData(day, auxiliaryData))
    )
  )
);
```

The `updateIn` isn't powerful enough to make the drilling less boilerplaty
(and less error-prone).

If you are a Haskell programmer, you might know that *lenses* are a solution
to this problem:

```haskell
data_ & months . traversed . days . traversed %~ \day ->
  injectAuxData day auxData

-- or without operators:
over
  (months . traversed . days . traversed)
  (\day -> injectAuxData day auxData)
  data_
```

And with this library you can write similar code in JavaScript:

```javascript
o.imkey("months").traversed().imkey("days").traversed().over(data, day =>
  injectAuxData(day, auxData)
);
```

## Documentation

There is small amount of run-time validation.
For example, if you try to *set* over `Getter`, the exception will be thrown:
```javascript
o.key("foo").to(function (x) { return x[0]; }).set(value, 42);
// throws: Trying to run Traversal operation via Getter
```

### Operations

- `get(this: Getter<S,A>, value: S): A`

- `set(this: Traversal<S,T,A,B>, value: S, b: B): T`

- `over(this: Traversal<S,T,A,B>, value: S, f: A => B): T`

- `review(this: Prism<S,T,A,B>, value: B): T`
- `review(this: Iso<S,T,A,B>, value: B): T`

  Construct value thru `Prism` or `Iso`.

- `affineView(this: Affine<S,T,A,B>, def: A): A

  For operation working with `Fold`, see `firstOf`.

- `reduceOf(this: Fold<S,T,A,B>, value: S, init: I, combine: (I, A) => I): I`

  Fold starting with initial value `init`, and combining results with `combine`,
  in the `this` Fold's order.

- `arrayOf(this: Fold<S,T,A,B>, value: S): Array<A>`

- `sumOf(this: Fold<S,T,number,B>, value: S): number`

### Constructors

- `lens(getter: S => A, setter: (S, B) => T): Lens<S,T,A,B>`

- `traversed(): Traversal<F<A>,F<B>,A,B>`

  Creates traversal for everything with `.map` and `.forEach`.

- `to(f: S => A): Getter<S,A>`

### Convenient optics

- `key(K: keyof (S & T)): Lens<S,T,S[K],T[K]>`

  Works for *plain-old-javascriot-objects*, i.e. POJOs :)

- `idx(i: number)): Lens<Array<A>,Array<A>,A,A>`

- `imkey(K: keyof (S & T)): Lens<Record<S>,Record<T>,S[K],T[K]>`

  Works with everyting supporting `.get` and `.set`, e.g.
  [Immutable](http://facebook.github.io/immutable-js/).

- `imidx(i: number)): Lens<List<A>,List<A>,A,A>`

  Works with everyting supporting `.get` and `.set`, e.g.
  [Immutable](http://facebook.github.io/immutable-js/).

  *Note:* doesn't perform bounds check.

- `filtered(pred: A => boolean): Prism<A,A,A',A'>`

*Note*: The predicate is checked when the value is injected (via `Traversal`)
or constructed via `Prism`.

- `safeFiltered(pred: A => boolean): Prism<A,A,A',A'>`

Like `filtered` but predicate is checked on construction.

### Internals

Functions which you probably never need to use directly.

`.o(this: Optic<S,T,A,B>, other: Optic<A,B,U,V>): Optic<S,T,U,V>`

Compose two optics.

`.run(this: Optic<S,T,A,B>, p: Profunctor<A,B>): Profunctor<S,T>`

## Contributing

- `README.md` is generated from the source with [ljs](https://github.com/phadej/ljs), say `make literate`.
- `optika.standalone.js` is also generated by the build process
- Before creating a pull request run `make test`, yet travis will do it for you.

## Release History

- **0.0.2** &mdash; *2017-04-01* &mdash; Neglect for speedups
- **0.0.1** &mdash; *2017-03-24* &mdash; More features
- **0.0.0** &mdash; *2017-03-22* &mdash; Initial preview

## Implementation details

- pair is represented as two-element array: `Pair<A,B> = [A,B]`.
- `Either` is represtented by `[boolean, A | B]`, where
  `false` and `true` reprsent whether the value is `Left` or `Right` respectively.
- `Maybe` is encoded as the value + some unique value nothing can equal to (think: `Symbol`).
- See [Compiling lenses](http://oleg.fi/gists/posts/2017-03-31-compiling-lenses.html)
  for ideas behind `Neglect`.

## Related work

### JavaScript

- [partial.lenses](https://github.com/calmm-js/partial.lenses)
- [ramda-lens](https://github.com/ramda/ramda-lens)
- [flunc-optics](https://github.com/flunc/optics)
- [monocle-ts](https://github.com/gcanti/monocle-ts)

The MIT License (MIT)

Copyright (c) 2017 Oleg Grenrus

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
